\name{convert_popedInput}
\alias{convert_popedInput}
\title{Convert the poped input file to a database that can be used by PopED.}
\usage{
convert_popedInput(popedInput,
  strPopEDVersion = poped.choose(popedInput$strPopEDVersion,
  packageVersion("PopED")), modtit = poped.choose(popedInput$modtit,
  "PopED model"), output_file = poped.choose(popedInput$output_file,
  paste("PopED_output", "_summary", sep = "")),
  output_function_file = poped.choose(popedInput$output_function_file,
  paste("PopED", "_output_", sep = "")),
  strIterationFileName = poped.choose(popedInput$strIterationFileName,
  paste("PopED", "_current.R", sep = "")),
  optsw = poped.choose(popedInput$optsw, cbind(0, 0, 0, 0, 0)),
  xt = poped.choose(popedInput$design[["xt"]],
  stop("'xt' needs to be defined")), m = poped.choose(popedInput[["m"]],
  size(xt, 1)), x = poped.choose(popedInput$design[["x"]], zeros(m, 0)),
  nx = poped.choose(popedInput$nx, size(x, 2)),
  a = poped.choose(popedInput$design[["a"]], zeros(m, 0)),
  na = poped.choose(popedInput$na, size(a, 2)),
  groupsize = poped.choose(popedInput$design$groupsize,
  stop("'groupsize' needs to be defined")),
  ni = poped.choose(popedInput$design$ni, matrix(size(xt, 2), m, 1)),
  model_switch = poped.choose(popedInput$design$model_switch, ones(size(xt,
  1), size(xt, 2))), maxni = poped.choose(popedInput$maxni, size(xt, 2)),
  minni = poped.choose(popedInput$minni, 1),
  maxgroupsize = poped.choose(popedInput$design$maxgroupsize, groupsize),
  mingroupsize = poped.choose(popedInput$design$mingroupsize, ones(m, 1)),
  maxtotgroupsize = poped.choose(popedInput$design$maxtotgroupsize,
  sum(groupsize)),
  mintotgroupsize = poped.choose(popedInput$design$mintotgroupsize,
  sum(mingroupsize)), maxxt = poped.choose(popedInput$design$maxxt, xt),
  minxt = poped.choose(popedInput$design$minxt, xt),
  discrete_x = poped.choose(popedInput$design$discrete_x, cell(m, nx)),
  maxa = poped.choose(popedInput$design$maxa, a),
  mina = poped.choose(popedInput$design$mina, a),
  bUseGrouped_xt = poped.choose(popedInput$bUseGrouped_xt, FALSE),
  G_xt = poped.choose(popedInput$design$G, matrix(seq(1, length(xt), len =
  length(xt)), size(xt, 1), size(xt, 2), byrow = T)),
  bUseGrouped_a = poped.choose(popedInput$bUseGrouped_a, FALSE),
  G_a = poped.choose(popedInput$design$Ga, matrix(seq(1, length(a), len =
  length(a)), size(a, 1), size(a, 2), byrow = T)),
  bUseGrouped_x = poped.choose(popedInput$bUseGrouped_x, FALSE),
  G_x = poped.choose(popedInput$design$Gx, matrix(seq(1, length(x), len =
  length(x)), size(x, 1), size(x, 2), byrow = T)),
  iFIMCalculationType = poped.choose(popedInput$iFIMCalculationType, 1),
  iApproximationMethod = poped.choose(popedInput$iApproximationMethod, 0),
  iFOCENumInd = poped.choose(popedInput$iFOCENumInd, 1000),
  prior_fim = poped.choose(popedInput$prior_fim, matrix(0, 0, 1)),
  strAutoCorrelationFile = poped.choose(popedInput$strAutoCorrelationFile,
  ""), d_switch = poped.choose(popedInput$d_switch, 1),
  ofv_calc_type = poped.choose(popedInput$ofv_calc_type, 1),
  ds_index = popedInput$CriterionOptions$ds_index,
  strEDPenaltyFile = poped.choose(popedInput$strEDPenaltyFile, ""),
  iEDCalculationType = poped.choose(popedInput$iEDCalculationType, 0),
  ED_samp_size = poped.choose(popedInput$ED_samp_size, 45),
  bLHS = poped.choose(popedInput$bLHS, 1),
  strUserDistributionFile = poped.choose(popedInput$strUserDistributionFile,
  ""), nbpop = popedInput$nbpop, NumRanEff = popedInput$nb,
  NumDocc = popedInput$ndocc, NumOcc = popedInput$NumOcc,
  ng = popedInput$ng, bpop_descr = popedInput$design$bpop,
  d_descr = popedInput$design$d, covd = poped.choose(popedInput$design$covd,
  zeros(1, size(d_descr, 1)) * (size(d_descr, 1) - 1)/2),
  sigma = popedInput$design$sigma,
  docc = poped.choose(popedInput$design$docc, matrix(0, 0, 3)),
  covdocc = poped.choose(popedInput$design$covdocc, zeros(1, length(docc[, 2,
  drop = F]) * (length(docc[, 2, drop = F]) - 1)/2)),
  notfixed_bpop = popedInput$notfixed_bpop,
  notfixed_d = popedInput$notfixed_d,
  notfixed_covd = popedInput$notfixed_covd,
  notfixed_docc = popedInput$notfixed_docc,
  notfixed_covdocc = poped.choose(popedInput$notfixed_covdocc, zeros(1,
  length(covdocc))), notfixed_sigma = poped.choose(popedInput$notfixed_sigma,
  t(rep(1, length(diag(sigma))))),
  notfixed_covsigma = poped.choose(popedInput$notfixed_covsigma, zeros(1,
  length(notfixed_sigma) * (length(notfixed_sigma) - 1)/2)),
  bUseRandomSearch = poped.choose(popedInput$bUseRandomSearch, TRUE),
  bUseStochasticGradient = poped.choose(popedInput$bUseStochasticGradient,
  TRUE), bUseLineSearch = poped.choose(popedInput$bUseLineSearch, TRUE),
  bUseExchangeAlgorithm = poped.choose(popedInput$bUseExchangeAlgorithm,
  FALSE), bUseBFGSMinimizer = poped.choose(popedInput$bUseBFGSMinimizer,
  FALSE), EACriteria = poped.choose(popedInput$EACriteria, 1),
  strRunFile = poped.choose(popedInput$strRunFile, ""),
  user_data = poped.choose(popedInput$user_data, cell(0, 0)),
  ourzero = poped.choose(popedInput$ourzero, 1e-05),
  dSeed = poped.choose(popedInput$dSeed, -1),
  line_opta = poped.choose(popedInput$line_opta, TRUE),
  line_optx = poped.choose(popedInput$line_optx, TRUE),
  bShowGraphs = poped.choose(popedInput$bShowGraphs, FALSE),
  use_logfile = poped.choose(popedInput$use_logfile, FALSE),
  m1_switch = poped.choose(popedInput$m1_switch, 1),
  m2_switch = poped.choose(popedInput$m2_switch, 1),
  hle_switch = poped.choose(popedInput$hle_switch, 1),
  gradff_switch = poped.choose(popedInput$gradff_switch, 1),
  gradfg_switch = poped.choose(popedInput$gradfg_switch, 1),
  rsit_output = poped.choose(popedInput$rsit_output, 5),
  sgit_output = poped.choose(popedInput$sgit_output, 1),
  hm1 = poped.choose(popedInput$hm1, 1e-05),
  hlf = poped.choose(popedInput$hlf, 1e-05),
  hlg = poped.choose(popedInput$hlg, 1e-05),
  hm2 = poped.choose(popedInput$hm2, 1e-05),
  hgd = poped.choose(popedInput$hgd, 1e-05),
  hle = poped.choose(popedInput$hle, 1e-05),
  AbsTol = poped.choose(popedInput$AbsTol, 1e-05),
  RelTol = poped.choose(popedInput$RelTol, 1e-05),
  iDiffSolverMethod = poped.choose(popedInput$iDiffSolverMethod, 0),
  bUseMemorySolver = poped.choose(popedInput$bUseMemorySolver, FALSE),
  rsit = poped.choose(popedInput$rsit, 300),
  sgit = poped.choose(popedInput$sgit, 150),
  intrsit = poped.choose(popedInput$intrsit, 250),
  intsgit = poped.choose(popedInput$intsgit, 50),
  maxrsnullit = poped.choose(popedInput$maxrsnullit, 50),
  convergence_eps = poped.choose(popedInput$convergence_eps, 1e-08),
  rslxt = poped.choose(popedInput$rslxt, 10),
  rsla = poped.choose(popedInput$rsla, 10),
  cfaxt = poped.choose(popedInput$cfaxt, 0.001),
  cfaa = poped.choose(popedInput$cfaa, 0.001),
  bGreedyGroupOpt = poped.choose(popedInput$bGreedyGroupOpt, FALSE),
  EAStepSize = poped.choose(popedInput$EAStepSize, 0.01),
  EANumPoints = poped.choose(popedInput$EANumPoints, FALSE),
  EAConvergenceCriteria = poped.choose(popedInput$EAConvergenceCriteria,
  1e-20), bEANoReplicates = poped.choose(popedInput$bEANoReplicates, FALSE),
  BFGSConvergenceCriteriaMinStep = poped.choose(popedInput$BFGSConvergenceCriteriaMinStep,
  1e-08),
  BFGSProjectedGradientTol = poped.choose(popedInput$BFGSProjectedGradientTol,
  1e-04), BFGSTolerancef = poped.choose(popedInput$BFGSTolerancef, 0.001),
  BFGSToleranceg = poped.choose(popedInput$BFGSToleranceg, 0.9),
  BFGSTolerancex = poped.choose(popedInput$BFGSTolerancex, 0.1),
  ED_diff_it = poped.choose(popedInput$ED_diff_it, 30),
  ED_diff_percent = poped.choose(popedInput$ED_diff_percent, 10),
  line_search_it = poped.choose(popedInput$line_search_it, 50),
  iNumSearchIterationsIfNotLineSearch = poped.choose(popedInput$iNumSearchIterationsIfNotLineSearch,
  1),
  iCompileOption = poped.choose(popedInput$parallelSettings$iCompileOption,
  -1),
  iUseParallelMethod = poped.choose(popedInput$parallelSettings$iUseParallelMethod,
  1),
  strAdditionalMCCCompilerDependencies = poped.choose(popedInput$parallelSettings$strAdditionalMCCCompilerDependencies,
  ""),
  strExecuteName = poped.choose(popedInput$parallelSettings$strExecuteName,
  "calc_fim.exe"),
  iNumProcesses = poped.choose(popedInput$parallelSettings$iNumProcesses, 2),
  iNumChunkDesignEvals = poped.choose(popedInput$parallelSettings$iNumChunkDesignEvals,
  -2),
  strMatFileInputPrefix = poped.choose(popedInput$parallelSettings$strMatFileInputPrefix,
  "parallel_input"),
  strMatFileOutputPrefix = poped.choose(popedInput$parallelSettings$strMatFileOutputPrefix,
  "parallel_output"),
  strExtraRunOptions = poped.choose(popedInput$parallelSettings$strExtraRunOptions,
  ""),
  dPollResultTime = poped.choose(popedInput$parallelSettings$dPollResultTime,
  0.1),
  strFunctionInputName = poped.choose(popedInput$parallelSettings$strFunctionInputName,
  "function_input"),
  bParallelRS = poped.choose(popedInput$parallelSettings$bParallelRS, FALSE),
  bParallelSG = poped.choose(popedInput$parallelSettings$bParallelSG, FALSE),
  bParallelMFEA = poped.choose(popedInput$parallelSettings$bParallelMFEA,
  FALSE), bParallelLS = poped.choose(popedInput$parallelSettings$bParallelLS,
  FALSE))
}
\arguments{
  \item{popedInput}{An input file to PopED}

  \item{iCompileOption}{\bold{******START OF PARALLEL
  OPTIONS**********} Compile options for PopED \itemize{
  \item -1 = No compilation, \item 0 or 3 = Full
  compilation, \item 1 or 4 = Only using MCC (shared lib),
  \item 2 or 5 = Only MPI, \item Option 0,1,2 runs PopED
  and option 3,4,5 stops after compilation }}
}
\value{
A PopED database
}
\description{
The function takes the defined input from poped and creates
a database for use in other PopED functions. Typically this
function will not be accessed by the user.  Instead, use
the function \code{\link{create.poped.database}}
}
\seealso{
Other poped_input: \code{\link{convert_variables}};
\code{\link{create.poped.database}};
\code{\link{downsizing_general_design}}
}

