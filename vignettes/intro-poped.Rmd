---
title: "Introduction to PopED"
author: "Andrew Hooker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{1. Introduction to PopED}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

PopED computes optimal experimental designs for both population and individual studies based on nonlinear mixed-effect models. Often this is based on a computation of the Fisher Information Matrix (FIM).

To get started you need to define

* A model.
* An initial design (and design space if you want to optimize)
* The tasks to perform.

There are a number of functions to help you with these tasks.  See `?poped` for more information.  
 
Below is an example to introduce the package.  There are several other examples, as r-scripts, in the "examples" folder in the 
PopED installation directory located at:


```
system.file("examples", package="PopED")
```

## Define a model

Here we define a one-compartment pharmacokinetic model with linear absorption using an analytical solution.  In this case the solution is applicable for both multiple and single dosing.  Note that this function is also predefined in PopED as `ff.PK.1.comp.oral.md.CL`.

```{r,eval=TRUE}
library(PopED)
```


```{r,include = FALSE}
set.seed(1234)
knitr::opts_chunk$set(cache = FALSE)
```



```{r struct_model}
ff <- function(model_switch,xt,parameters,poped.db){
  with(as.list(parameters),{
    N = floor(xt/TAU)+1
    y=(DOSE*Favail/V)*(KA/(KA - CL/V)) * 
      (exp(-CL/V * (xt - (N - 1) * TAU)) * (1 - exp(-N * CL/V * TAU))/(1 - exp(-CL/V * TAU)) - 
         exp(-KA * (xt - (N - 1) * TAU)) * (1 - exp(-N * KA * TAU))/(1 - exp(-KA * TAU)))  
    return(list( y=y,poped.db=poped.db))
  })
}
```

Next we define the parameters of this function, in this case log-normal distributions around the parameters (not `Favail`).  `DOSE` and `TAU` are defined as a covariates (`a`) so that we can optimize these values later.
```{r}
sfg <- function(x,a,bpop,b,bocc){
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU=a[2])
}
```

Now we define the residual unexplained variability (RUV) function, in this case the RUV has both an additive and proportional component.
```{r}
feps <- function(model_switch,xt,parameters,epsi,poped.db){
  returnArgs <- ff(model_switch,xt,parameters,poped.db) 
  y <- returnArgs[[1]]
  poped.db <- returnArgs[[2]]
 
  y = y*(1+epsi[,1])+epsi[,2]
  
  return(list(y=y,poped.db=poped.db)) 
}
```


We have now defined all aspects of the model.

## Define an initial design and design space

Now we define the model parameter values, the initial design  and design space for optimization.

In this example, the parameter values are defined for the fixed effects (`bpop`), the between-subject variability variances (`d`) and the residual variability variances (`sigma`).  We also fix the parameter `Favail` using `notfixed_bpop`, since we have only oral dosing and the parameter is not identifiable.  Fixing a parameter means that we assume the parameter will not be estimated.  In addition, we fix the small additive RUV term, as this term is reflecting the higher error expected at low concentration measurements (limit of quantification measurements) and would typically be calculated from analytical assay methods (for example, the standard deviation of the parameter might be 20% of the limit of quantification).


For the initial design, we define two groups (`m=2`) of 20 individuals (`groupsize=20`), with doses of 20 mg or 40 mg every 24 hours (`a`).   The initial design has 5 sample times per individual (`xt`). For the design space, which can be searched during optimization, we define a potential dose range of between 0 and 200 mg (`mina` and `maxa`), and a range of potential sample times between 0 and 10 hours for the first three samples and between 240 and 248 hours for the last two samples (`minxt` and `maxxt`).   Finally, we fix the two groups of subjects to have the sample sample times (`bUseGrouped_xt=TRUE`). 

```{r}
poped.db <- create.poped.database(ff_fun=ff,
                                  fg_fun=sfg,
                                  fError_fun=feps,
                                  bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(V=0.09,KA=0.09,CL=0.25^2), 
                                  sigma=c(0.04,5e-6),
                                  notfixed_sigma=c(1,0),
                                  m=2,
                                  groupsize=20,
                                  a=list(c(DOSE=20,TAU=24),c(DOSE=40, TAU=24)),
                                  maxa=c(DOSE=200,TAU=24),
                                  mina=c(DOSE=0,TAU=24),
                                  xt=c( 1,2,8,240,245),
                                  minxt=c(0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248),
                                  bUseGrouped_xt=TRUE)
```

##  The tasks to perform.

### Simulation
First it may make sense to check your model and design to make sure you get what you expect when simulating data.  Here we plot the model typical values:
```{r, fig.width=6}
plot_model_prediction(poped.db, model_num_points = 500)
```

Next, we plot the model typical values prediction intervals taking into account the between-subject variability (you can even investigate the effects of the residual, unexplained, variability with the `DV=T` argument): 
```{r simulate_with_BSV, fig.width=6}
plot_model_prediction(poped.db, model_num_points=500, IPRED=T)
```

We can get these predictions numerically as well:
```{r}
dat <- model_prediction(poped.db,DV=T)
head(dat,n=5);tail(dat,n=5)
```

### Design evaluation
Next, we evaluate the initial design
```{r}
evaluate_design(poped.db)
```
We see that the fixed-effect and residual variability parameters are relatively well estimated with this design, but the between-subject variability parameters are less well estimated.

### Design optimization
Now we can optimize the sample times of the design^[Tip:  to make the optimization run faster use the option `parallel = T` in the `poped_optim` command.].
```{r optimize,message = FALSE,results='hide',cache=TRUE}
output <- poped_optim(poped.db, opt_xt=T)
```


```{r, fig.width=6}
summary(output)
plot_model_prediction(output$poped.db)
```


We see that there are four distinct sample times for this design.  This means that for this model, with these exact parameter values, that the most information from the study to inform the parameter estimation is with these sample times.  

### Examine efficiency of sampling windows
Of course, this means that there are multiple samples at some of these time points.  We can explore a more practical design by looking at the loss of efficiency if we spread out sample times in a uniform distribution around these optimal points ($\pm 30$ minutes).  
```{r,fig.width=6,fig.height=6,cache=TRUE}
plot_efficiency_of_windows(output$poped.db,xt_windows=0.5)
```

Here we see the efficiency ($(|FIM_{optimized}|/|FIM_{initial}|)^{1/npar}$) drop below 80% in some cases, which is mostly caused by an increase in the D[2,2] parameter uncertainty (BSV on absorption).  Smaller windows or different windowing on different samples may be in order here.  To investigate see `?plot_efficiency_of_windows`. 

### Optimize over a discrete design space
In the previous example we optimized over a continuous design space (sample times could be optimized to be any value between a lower and an upper limit).  We could also limit the search to only "allowed" values, for example, only samples taken on the hour are allowed.

```{r, message = FALSE,results='hide'}
poped.db.discrete <- create.poped.database(poped.db,discrete_xt = list(0:248))
                                          
output_discrete <- poped_optim(poped.db.discrete, opt_xt=T)

```

```{r,fig.width=6}
summary(output_discrete)
plot_model_prediction(output_discrete$poped.db)
```

Here we see that the optimization ran somewhat quicker, but gave a less efficient design.

### Optimize 'Other' design variables
One could also optimize over dose, to see if a different dose could help in parameter estimation .
```{r optimize_dose,message = FALSE,results='hide', eval=FALSE,cache=TRUE}
output_dose_opt <- poped_optim(output$poped.db, opt_xt=T, opt_a=T)
```


In this case the results are predictable ... higher doses give observations with somewhat lower absolute residual variability leading to both groups at the highest allowed dose levels (200 mg in this case).

### Cost function to optimize dose
Optimizing the dose of a study just to have better model parameter estimates may be somewhat implausible. Instead, let's use a cost function to optimize dose based on some sort of target concentration ... perhaps typical population trough concentrations of 0.2 and 0.35 for the two groups of patients at 240 hours. 

First we define the criteria we use to optimize the doses, here a least squares minimization.
```{r}
crit_fcn <- function(poped.db,...){
  pred_df <- model_prediction(poped.db)
  sum((pred_df[pred_df["Time"]==240,"PRED"] - c(0.2,0.35))^2)
}
crit_fcn(output$poped.db)
```

Now we minimize the cost function 
```{r cost_optimization, message = FALSE,results='hide',cache=TRUE}
output_cost <- poped_optim(poped.db, opt_a =T, opt_xt = F,
                     ofv_fun=crit_fcn,
                     maximize = F)
```

```{r, fig.width=6}
summary(output_cost)
get_rse(output_cost$FIM, output_cost$poped.db)
plot_model_prediction(output_cost$poped.db)
```

# Examples

In this section, further PopED features are described within a series of examples that are stored at the usual directory, located at:

```
system.file("examples", package="PopED")
```

Of note, only the code related to the specific "new" feature is here described. The complete R code is in the corresponding R script related to each of the examples.

##1.	One comp first order absorption - analytical solution for both mutiple and single dosing (design evaluation); design evaluation and design optimization of times and/or doses over a continuous or discrete design space.

This example is the intro example illustrated in the first part of this document, before the Examples section.
The corresponding R script is the PopED example "ex.1.a.PK.1.comp.oral.md.intro.R"

##2.	PKPD model (analytical equations) & multiple arms (different doses, sampling times)- design optimization using Line Search (LS) method	

This corresponds to example "ex.4.PKPD.1.comp.emax.R", with object names update. It would be nice to have the plot function "plot_model_prediction" updated for this example, so that in the plot we see the name of the models, i.e. PK and PD, instead of the current predefined form, i.e. Model 1 and Model 2.

### Define a model

Here we define a PKPD mode using analytical equations. The PK is a one compartment model with intravenus bolus administration and linear elimination, whereas the PD is an ordinary Emax model.
```{r}
f_pkpdmodel <- function(model_switch,xt,parameters,poped.db){
  with(as.list(parameters),{
    y=xt
    MS <- model_switch
    
    # PK model
    CONC = DOSE/V*exp(-CL/V*xt) 
    
    # PD model
    EFF = E0 + CONC*EMAX/(EC50 + CONC)
    
    y[MS==1] = CONC[MS==1]
    y[MS==2] = EFF[MS==2]
    
    return(list( y= y,poped.db=poped.db))
  })
}
```

```{r, echo=FALSE}
## -- parameter definition function
## ETAs into Parameter Values
f_etaToParam <- function(x,a,bpop,b,bocc){
  parameters=c( 
    CL=bpop[1]*exp(b[1])  ,
    V=bpop[2]*exp(b[2])	,
    E0=bpop[3]*exp(b[3])	,
    EMAX=bpop[4],
    EC50=bpop[5]*exp(b[4])	,
    DOSE=a[1]
  )
  return( parameters ) 
}
```

The error model has to accommodate both response models:
```{r}
## -- Residual Error function
## -- Proportional PK + additive PD
f_Err <- function(model_switch,xt,parameters,epsi,poped.db){
  returnArgs <- do.call(poped.db$model$ff_pointer,list(model_switch,xt,parameters,poped.db)) 
  y <- returnArgs[[1]]
  poped.db <- returnArgs[[2]]
  
  MS <- model_switch
  
  prop.err <- y*(1+epsi[,1])
  add.err <- y+epsi[,2]
  
  y[MS==1] = prop.err[MS==1]
  y[MS==2] = add.err[MS==2]
  
  return(list( y= y,poped.db =poped.db )) 
}
```

### Define design and design space

We specify in the poped.db object the vector "model_switch" in order to assign the sampling times written in the vector "xt" to the PK (1) or PD (2) models. 

```{r}
poped.db <- create.poped.database(ff_fun=f_pkpdmodel,
                                  fError_fun=f_Err,
                                  fg_fun=f_etaToParam,
                                  groupsize=20,
                                  m=3,
                                  sigma=diag(c(0.15,0.015)),
                                  bpop=c(CL=0.5,V=0.2,E0=1,EMAX=1,EC50=1),  
                                  d=c(CL=0.09,V=0.09,E0=0.04,EC50=0.09), 
                                  xt=c( 0.33,0.66,0.9,5,0.1,1,2,5),
                                  bUseGrouped_xt=1,
                                  model_switch=c(1,1,1,1,2,2,2,2),
                                  minxt=0,
                                  maxxt=5,
                                  ourzero = 0,
                                  a=list(c(DOSE=0),c(DOSE=1),c(DOSE=2)),
                                  maxa=c(DOSE=10),
                                  mina=c(DOSE=0))


```

Below the model predictions of the typical PK and PD profiles, i.e. Model 1 and Model 2, respectively, for three dose groups, are displayed. The current design, as shown in the "poped.db" object, consists in 3 arms with dose 0,1, and 2 per arm; PK times of 0.33,0.66,0.9,5 hours; PD times of 0.1,1,2,5 hours.

```{r,fig.width=6,fig.height=6}
plot_model_prediction(poped.db,IPRED=T,DV=T,facet_scales="free",separate.groups=T) 
```

## Optimal design (doses and times) using the LS method

```{r,message = FALSE,results='hide',cache=TRUE}
output <- poped_optim(poped.db, opt_xt = T, opt_a = T, parallel = T,method = c("LS"))
```

We can similarly plot the predicted typical PK and PD profiles for the optimal design:

```{r,fig.width=6,fig.height=6}
plot_model_prediction(output$poped.db,IPRED=T,DV=T,facet_scales="free",separate.groups=T) 
```

The results are printed in the R consol when the optimization is finalized. One can also retreive them from the "output" object.

The optimal doses and sampling times obtained by Linear Search optimizations are retreived with the following:

```{r}
output$poped.db$design
```


##4.	Two compartment model with oral absorption using ODEs	

"ex.9.PK.2.comp.oral.md.ode.compiled.R"

##5.	Different dose regimens per arm	

In ex.8.tmdd_qss_one_target_compiled.R there is an example of different sampling schemes per arm using matrices. This starts at line 190.

##6.	Model with discrete covariates	

##7.	Model with continuous covariates	

##8.	Model with Inter-occasion variability and full covariance matrix	

##9.	Handling BLQ data	

##10.	Include previous FIM

##11.	Robust design	

"ex.2.d.warfarin.ED.R"

##12.	Power Calculation	

##13.	Espresso design	

##Further examples	

14.	Shrinkage	
15.	Irregular dosing more complex: e.g. switching between s.c. and i.v. within one arm.	
16.	Constraining the optimization to different allowed sampling times for each group	
17.	Constraining the optimization to different allowed sampling times for each response	
18.	Keep some sampling time fixed (they will be automatically part of the optimal design protocol)	
19.	Handling derived outputs	
20.	Symbolic differentiation	
